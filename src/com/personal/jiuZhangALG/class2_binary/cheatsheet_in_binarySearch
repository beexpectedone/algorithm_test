使用递归和非递归的权衡-----看面试管的要求，是不是特定不想要让你使用递归
使用T函数的时间复杂度计算方式

通用的二分法模板：
start + 1 < end
===》 写成 while( start + 1 < end )的形式，也是为了避免死循环的出现

int mid = start + (end - start) / 2
===》将 mid 写成这个形式时，是为了保证mid在某些情况下不越界，比如在取Integer值，

当end = 	Integer.MAX_VALUE时就有可能出现溢出的情况
A[mid] === <>
A[start] A[end] target
===》 在最后加上这一个部分，判断target值是和start还是和end值进行比较，
将所有可以使用二分法的问题都转换为找firstPosition 和 lastPosition的问题（这部分是重点）

两类二分法
    二分位置：Binary search on index
    二分答案 Binary search on result

理解二分法的三个层次：
    1.头尾指针，取中点，判断往哪儿走
    2.寻找满足某个条件的第一个或是最后一个位置
    3.b奥流剩下来一定有解的那一半

二分法进一步理解：保留有答案的那个部分
（二分法本质上就是不断地缩小答案的区间，保留有答案的那一个部分）

特别注意在RotatedArray 和 findPeak两种变体中，如果元素有重复的那么时间复杂度就变成了O（N),
其实某种程度上也就不能再使用二分法了。